package de.fuberlin.wiwiss.d2rq.algebra;

import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;

import com.hp.hpl.jena.graph.Node;
import com.hp.hpl.jena.graph.Triple;

import de.fuberlin.wiwiss.d2rq.nodes.NodeMaker;
import de.fuberlin.wiwiss.d2rq.sql.ResultRow;

/**
 * A respresentation of a d2rq:PropertyBridge, describing how
 * a set of virtual triples are to be obtained
 * from a database. The virtual subjects, predicates and objects
 * are generated by {@link NodeMaker}s.
 *
 * @author Chris Bizer chris@bizer.de
 * @author Richard Cyganiak (richard@cyganiak.de)
 * @version $Id: RDFRelationImpl.java,v 1.3 2006/09/11 23:22:24 cyganiak Exp $
 */
public class RDFRelationImpl implements RDFRelation {
	private NodeMaker subjectMaker;
	private NodeMaker predicateMaker;
	private NodeMaker objectMaker; 
	private Relation baseRelation;
	private Set projectionColumns = new HashSet();
	private boolean isUnique;
	
	public RDFRelationImpl(Relation baseRelation, NodeMaker subjectMaker, NodeMaker predicateMaker, NodeMaker objectMaker) {
		this.subjectMaker = subjectMaker;
		this.predicateMaker = predicateMaker;
		this.objectMaker = objectMaker;
		this.baseRelation = baseRelation;
		this.projectionColumns.addAll(this.subjectMaker.projectionColumns());
		this.projectionColumns.addAll(this.predicateMaker.projectionColumns());
		this.projectionColumns.addAll(this.objectMaker.projectionColumns());
		this.isUnique = determineIsUnique();
	}
	
	public Relation baseRelation() {
		return this.baseRelation;
	}
	
	public boolean isUnique() {
		return this.isUnique;
	}
	
	public Set projectionColumns() {
		return this.projectionColumns;
	}

	public NodeMaker nodeMaker(int index) {
		switch (index) {
			case 0: return this.subjectMaker; 
			case 1: return this.predicateMaker;
			case 2: return this.objectMaker;
			default: throw new IllegalArgumentException(Integer.toString(index));
		}
	}
    
	public String toString() {
		return "PropertyBridge(\n" +
				"    " + this.subjectMaker + "\n" +
				"    " + this.predicateMaker + "\n" +
				"    " + this.objectMaker + "\n" +
				")";
	}
	
	public RDFRelation withPrefix(int index) {
		Set tables = new HashSet();
		Iterator it = this.projectionColumns.iterator();
		while (it.hasNext()) {
			Attribute column = (Attribute) it.next();
			tables.add(column.tableName());
		}
		it = this.baseRelation.joinConditions().iterator();
		while (it.hasNext()) {
			Join join = (Join) it.next();
			tables.add(join.getFirstTable());
			tables.add(join.getSecondTable());
		}
		it = this.baseRelation.condition().columns().iterator();
		while (it.hasNext()) {
			Attribute column = (Attribute) it.next();
			tables.add(column.tableName());
		}
		Map prefixRenames = new HashMap();
		it = tables.iterator();
		while (it.hasNext()) {
			String tableName = (String) it.next();
			prefixRenames.put("T" + index + "_" + tableName, tableName);
		}
		return renameColumns(new AliasMap(prefixRenames));
	}
	
	public Collection makeTriples(ResultRow row) {
		Node s = this.subjectMaker.makeNode(row);
		Node p = this.predicateMaker.makeNode(row);
		Node o = this.objectMaker.makeNode(row);
		if (s == null || p == null || o == null) {
			return Collections.EMPTY_LIST;
		}
		return Collections.singleton(new Triple(s, p, o));
	}
	
	public RDFRelation selectTriple(Triple t) {
		MutableRelation newBase = new MutableRelation(this.baseRelation);
		NodeMaker s = this.subjectMaker.selectNode(t.getSubject(), newBase);
		if (s.equals(NodeMaker.EMPTY)) return RDFRelation.EMPTY;
		NodeMaker p = this.predicateMaker.selectNode(t.getPredicate(), newBase);
		if (p.equals(NodeMaker.EMPTY)) return RDFRelation.EMPTY;
		NodeMaker o = this.objectMaker.selectNode(t.getObject(), newBase);
		if (o.equals(NodeMaker.EMPTY)) return RDFRelation.EMPTY;
		return new RDFRelationImpl(newBase.immutableSnapshot(), s, p, o);
	}
	
	public RDFRelation renameColumns(ColumnRenamer renamer) {
		NodeMaker s = this.subjectMaker.renameColumns(renamer, MutableRelation.DUMMY);
		NodeMaker p = this.predicateMaker.renameColumns(renamer, MutableRelation.DUMMY);
		NodeMaker o = this.objectMaker.renameColumns(renamer, MutableRelation.DUMMY);
		return new RDFRelationImpl(this.baseRelation.renameColumns(renamer), s, p, o);
	}
	
	private boolean determineIsUnique() {
		if (this.baseRelation.joinConditions().isEmpty()) {
			return this.subjectMaker.isUnique() || this.predicateMaker.isUnique() || this.objectMaker.isUnique();
		}
		return false;
	}
}