The following is a list of optimizations and changes that were made to D2RQ by BBN.  

1. In addition to the PropertyBridge.couldFit() function, there was a
bridgeDoesFit function added to GraphD2RQ.  This ensures that only the property
bridge that fits the triple is used to make the query.  There were cases when
property bridges that could fit were being used to create a query and there was
data being returned that we did not ask for. 

2. A class called TripleRelationships was created to hold variable information
as well as the relationships between triples in the query.  This became crucial
during the process of splitting queries and proper aliasing. See the java doc
for more information.

3. Tables that have already been prefixed are no longer prefixed a second time
creating unnecessairy joins.  See the example below:

SPARQL Query:

CONSTRUCT {
    ?y <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <http://example.org/2006/04/example#foo.bar> . 
    ?y <http://example.org/2006/04/example#Id> ?id .
    ?y <http://example.org/2006/04/example#Source> ?Sub5 .
    ?Sub6 <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <http://example.org/2006/04/example#foo.name> .
    ?Sub6 <http://example.org/2006/04/example#Id> ?id .
} WHERE { 
    ?y <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <http://example.org/2006/04/example#foo.bar> ;
         <http://example.org/2006/04/example#Id> ?id ;
         <http://example.org/2006/04/example#Source> ?Sub5 .
    ?Sub6 <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <http://example.org/2006/04/example#foo.name> ;
              <http://example.org/2006/04/example#Id> ?id .
}

D2RQ-0.4 SQL Statement:

SELECT 
	T0_EXAMPLE.BAR.PK1, 
	T0_EXAMPLE.BAR.PK2, 
	T1_EXAMPLE.BAR.ID, 
	T1_EXAMPLE.BAR.PK1, 
	T1_EXAMPLE.BAR.PK2, 
	T2_EXAMPLE.BAR.PK2, 
	T2_EXAMPLE.BAR.PK1, 
	T2_EXAMPLE.BAR.SOURCE, 
	T3_EXAMPLE.NAME.PK3, 
	T3_EXAMPLE.NAME.PK1, 
	T3_EXAMPLE.NAME.PK2, 
	T4_EXAMPLE.NAME.ID, 
	T4_EXAMPLE.NAME.PK3, 
	T4_EXAMPLE.NAME.PK2, 
	T4_EXAMPLE.NAME.PK1 
FROM 
	EXAMPLE AS T2_EXAMPLE, 
	EXAMPLE AS T4_EXAMPLE , 
	EXAMPLE AS T1_EXAMPLE , 
	EXAMPLE AS T3_EXAMPLE , 
	EXAMPLE AS T0_EXAMPLE 
WHERE 
	T1_EXAMPLE.BAR.ID=T4_EXAMPLE.NAME.ID;

BBN Optimized SQL statement:

SELECT 
	T0_EXAMPLEPBAR.PK1, 
	T0_EXAMPLEPBAR.PK2, 
	T0_EXAMPLEPBAR.ID, 
	T0_EXAMPLEPBAR.SOURCE, 
	T3_EXAMPLEPNAME.PK2, 
	T3_EXAMPLEPNAME.PK1, 
	T3_EXAMPLEPNAME.PK3, 
	T3_EXAMPLEPNAME.ID 
FROM 
	EXAMPLE.BAR AS T0_EXAMPLEPBAR, 
	EXAMPLE.NAME AS T3_EXAMPLEPNAME 
WHERE 
	T3_EXAMPLEPNAME.ID=T0_EXAMPLEPBAR.ID

4. SQL Statements that can be seperated are seperated in the SQLStatementMaker. 
See below for an example of a seperated query:

SPARQL Query:

CONSTRUCT {
    ?y <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <http://example.org/2006/04/example#foo.bar> . 
    ?y <http://example.org/2006/04/example#Id> ?id .
    ?y <http://example.org/2006/04/example#Source> ?Sub5 .
    ?Sub6 <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <http://example.org/2006/04/example#foo.name> .
    ?Sub6 <http://example.org/2006/04/example#Id> ?firstName .
} WHERE { 
    ?y <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <http://example.org/2006/04/example#foo.bar> ;
         <http://example.org/2006/04/example#Id> ?id ;
         <http://example.org/2006/04/example#Source> ?Sub5 .
    ?Sub6 <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <http://example.org/2006/04/example#foo.name> ;
              <http://example.org/2006/04/example#Id> ?firstName .
}

Creates:

SELECT 
	T0_EXAMPLEPBAR.PK1, 
	T0_EXAMPLEPBAR.PK2, 
	T0_EXAMPLEPBAR.ID, 
	T0_EXAMPLEPBAR.SOURCE
FROM 
	EXAMPLE.BAR AS T0_EXAMPLEPBAR

and

SELECT 
	T3_EXAMPLEPNAME.PK2, 
	T3_EXAMPLEPNAME.PK1, 
	T3_EXAMPLEPNAME.PK3, 
	T3_EXAMPLEPNAME.FIRST_NAME 
FROM 
	EXAMPLE.NAME AS T3_EXAMPLEPNAME

5. A few changed had to be made to make D2RQ work with Oracle.  I believe that I
changed everything back to work with mySQL.  This consisted of only changing the
asContruction constant in Alias class to " " instead of " AS ".  Something
should be done to make this easily configurable.