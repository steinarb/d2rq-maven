A. From query String to graph interface (com.hp.hpl.jena.rdql)
==============================================================
Query query=new Query(string);
  query.setSource(model);
QueryEngine queryEngine=new QueryEngine(query);
QueryResults queryResults=queryEngine.exec(ResultBinding startBinding);  // impl: QueryResultsMem or QueryResultsStream
ResultBinding resultBinding=queryResults.next();
  resultBinding getValue(varName);  // or similar

=> queryEngine.exec() and QueryResults implement interface to graph.

class QueryEngine:
    Query query;
    public QueryResults exec(ResultBinding startBinding)
    {
        init() ;
        resultsIter = new ResultsIterator(query, startBinding) ;
        return new QueryResultsStream(query, this, resultsIter) ;
    } 
class ResultsIterator:
	ClosableIterator planIter;
    public ResultsIterator(Query q, ResultBinding presets)
    {	
    	graph=source.getGraph();
    	queryHandler=graph.queryHandler(); // jg specified by graph. override!
    	com.hp.hpl.jena.graph.query.Query graphQuery = new com.hp.hpl.jena.graph.query.Query();
    	  ... // set up graphQuery from Query
    	  !!! // graphQuery currently does not contain constraints!!!
 		BindingQueryPlan plan = queryHandler.prepareBindings(graphQuery, projectionVars); // override?
        planIter = plan.executeBindings() ;
	}        
	public hasNext() + next()
	   // convert from graph nodes to model nodes, checks constraints, ...
class QueryResultsStream:
    ?
    
B. Package com.hp.hpl.jena.graph.query
=========================================
interface BindingQueryPlan: 
   All Known Implementing Classes: SimpleQueryPlan 
   SimpleQueryPlan is an implementation of QueryPlan which uses the engine defined in Query to do the work.
   
class SimpleQueryPlan:
   public ExtendedIterator executeBindings() 
   {  return new SimpleQueryEngine( query.getTriples(), query.getSorter(), query.getConstraints() )
            .executeBindings( new ArrayList(), query.args().put( NamedTripleBunches.anon, graph ), variables );   
   }

class SimpleQueryEngine:
    private ExpressionSet constraint;
    private NamedTripleBunches triples;
    private TripleSorter sortMethod;
    private int variableCount;
   public ExtendedIterator executeBindings( List outStages, NamedGraphMap args, Node [] nodes )
        {
        Mapping map = new Mapping( nodes );
        ArrayList stages = new ArrayList();        
        addStages( stages, args, map ); // jg stages is output argument
        if (constraint.isComplex()) stages.add( new ConstraintStage( map, constraint ) );
        outStages.addAll( stages );
        variableCount = map.size();
        return filter( connectStages( stages, variableCount ) );
        }
   private void addStages( ArrayList stages, NamedGraphMap arguments, Mapping map )
        {
        Iterator it2 = triples.entrySetIterator();
        while (it2.hasNext())
            {
            Map.Entry e = (Map.Entry) it2.next();
            String name = (String) e.getKey();
            Cons nodeTriples = (Cons) e.getValue();
            Graph g = arguments.get( name );
            int nBlocks = Cons.size( nodeTriples ), i = nBlocks;
            Triple [] nodes = new Triple[nBlocks];
            while (nodeTriples != null)
                {
                nodes[--i] = nodeTriples.head;
                nodeTriples = nodeTriples.tail;
                }
            nodes = sortTriples( nodes );
            Stage next = g.queryHandler().patternStage( map, constraint, nodes ); // jg override!
            stages.add( next );
            }
        }
   
C. Things to override:
======================
 Graph.queryHandler()
 SimpleQueryHandler.patternStage( map, constraint, nodes )

D2RQPatternStage extends PatternStage extends Stage
D2RQPatternStage(Graph graph, Mapping map, ExpressionSet constraints, Triple[] triples) 