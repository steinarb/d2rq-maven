A. From query String to graph interface (all classes from com.hp.hpl.jena.rdql)
==============================================================
class jena.rdfquery
static query(String s, String dataURL, String language) {
  Query query=new Query(string);
    query.setSource(model);
  QueryEngine queryEngine=new QueryEngine(query);
  QueryResults queryResults=queryEngine.exec(ResultBinding startBinding);  // impl: QueryResultsMem or QueryResultsStream
  ResultBinding resultBinding=queryResults.next();
    resultBinding getValue(varName);  // or similar

=> queryEngine.exec() and QueryResults implement interface to graph.

class QueryEngine:
    Query query;
    public QueryResults exec(ResultBinding startBinding)
    {
        init() ;
        resultsIter = new ResultsIterator(query, startBinding) ;
        return new QueryResultsStream(query, this, resultsIter) ;
    } 
class ResultsIterator:(in class QueryEngine)
	ClosableIterator planIter;
    public ResultsIterator(Query q, ResultBinding presets)
    {	
    	graph=source.getGraph();
    	queryHandler=graph.queryHandler(); // jg specified by graph. override!
    	com.hp.hpl.jena.graph.query.Query graphQuery = new com.hp.hpl.jena.graph.query.Query();
    	  ... // set up graphQuery from Query
    	  !!! // graphQuery does not contain constraints in Jena 2.2 but in 2.3 !!!
 		BindingQueryPlan plan = queryHandler.prepareBindings(graphQuery, projectionVars); // override?
        planIter = plan.executeBindings() ;
	}        
	public hasNext() + next()
	   // convert from graph nodes to model nodes, checks constraints, ...
class QueryResultsStream:
    ?
    
B. Package com.hp.hpl.jena.graph.query
=========================================
Note: QueryHandler.patternStage( Mapping map, ExpressionSet constraints, Triple [] p )
is not called by this framework, but from com.hp.hpl.jena.graph.query.SimpleQueryEngine only.
SimpleQueryEngine is referenced by: 
  1. SimpleQueryPlan (BindingQueryPlan!) -> patternStage() is refinement of Simple framework
  2. Query (uses SimpleQueryPlan as default for its executeBindings()
  3. NamedTripleBunches.    
    
interface BindingQueryPlan: 
   All Known Implementing Classes: SimpleQueryPlan 
   SimpleQueryPlan is an implementation of QueryPlan which uses the engine defined in Query to do the work.
   
class SimpleQueryPlan:
   public ExtendedIterator executeBindings() 
   {  return new SimpleQueryEngine( query.getTriples(), query.getSorter(), query.getConstraints() )
            .executeBindings( new ArrayList(), query.args().put( NamedTripleBunches.anon, graph ), variables );   
   }

class SimpleQueryEngine:
    private ExpressionSet constraint;
    private NamedTripleBunches triples;
    private TripleSorter sortMethod;
    private int variableCount;
   public ExtendedIterator executeBindings( List outStages, NamedGraphMap args, Node [] nodes )
        {
        Mapping map = new Mapping( nodes );
        ArrayList stages = new ArrayList();        
        addStages( stages, args, map ); // jg stages is output argument
        if (constraint.isComplex()) stages.add( new ConstraintStage( map, constraint ) );
        outStages.addAll( stages );
        variableCount = map.size();
        return filter( connectStages( stages, variableCount ) );
        }
   private void addStages( ArrayList stages, NamedGraphMap arguments, Mapping map )
        {
        Iterator it2 = triples.entrySetIterator();
        while (it2.hasNext())
            {
            Map.Entry e = (Map.Entry) it2.next();
            String name = (String) e.getKey();
            Cons nodeTriples = (Cons) e.getValue();
            Graph g = arguments.get( name );
            int nBlocks = Cons.size( nodeTriples ), i = nBlocks;
            Triple [] nodes = new Triple[nBlocks];
            while (nodeTriples != null)
                {
                nodes[--i] = nodeTriples.head;
                nodeTriples = nodeTriples.tail;
                }
            nodes = sortTriples( nodes );
            Stage next = g.queryHandler().patternStage( map, constraint, nodes ); // jg override!
            stages.add( next );
            }
        }
   
C. Things to override:
======================
 Graph.queryHandler()
 SimpleQueryHandler.patternStage( map, constraint, nodes )

D2RQPatternStage extends PatternStage extends Stage
D2RQPatternStage(Graph graph, Mapping map, ExpressionSet constraints, Triple[] triples) 



Matching Variables:
===================
occours in Pattern.match (which in turn occours in PatternStage)
jena.graph.query.Element
	protected int index; // probably the index in domain.
    public abstract boolean match( Domain d, Node x );
Subclass Bind:
    match(d,x) changes Domain at index
Subclass Bound"
    match(d,x) checks x against d.get(index)
Subclass Fixed:
    protected Node fixed;
	match(d,x) checks x against fixed
	